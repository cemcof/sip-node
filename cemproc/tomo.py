import pathlib
import shutil
import time

import data_tools
from cemproc.are_tomo import AreTomo

from cemproc.ctf import CtfFind5
from cemproc.imod import Imod
from cemproc.micrograph import Micrograph, InvalidMicrographType, MicrographScanner
from cemproc.motioncor import MotionCorr3
from cemproc.tilt_series import StageSeriesAngleBased
from common import LmodEnvProvider, StateObj
from data_tools import DataTransferSource, DataRule, FsTransferSource, DataRulesWrapper
from experiment import ExperimentStorageEngine

# Key features to keep in mind:

# Reentrancy - keep progress even if disrupted, continue on relaunch and eventually end up done
# Continuous on the fly processing - scan and accept existing and new input
# Customizable via arguments, invocable from either python code or command line, so it can be integrated with qsub
# Uses simple filesystem (pathlib) as IO for input and results

class CemcofTomoWorkflow:
    def __init__(self, args, logger):
        self.logger = logger
        self.args = args

        self.source_dir = args.source_dir
        self.working_dir = args.working_dir
        self.working_dir.mkdir(parents=True, exist_ok=True)
        self.run_dir = self.working_dir / "_run"

        self.movie_patterns = DataRulesWrapper(args.movie_patterns) if isinstance(args.movie_patterns, data_tools.DataRule) \
            else DataRulesWrapper( data_tools.DataRule(patterns=args.movie_patterns, tags="movie"))
        self.gain_patterns = DataRulesWrapper(args.gain_patterns) if isinstance(args.gain_patterns, data_tools.DataRule) \
            else DataRulesWrapper( data_tools.DataRule(patterns=args.gain_patterns, tags="gain"))

        self.processed_mics_file = self.run_dir / "processed_mics.dat"
        self.last_id_file = self.run_dir / "last_tilt_id.dat"
        self.processed_mics = set()
        self.next_tilt_id = 0

        self._load_state()
        self.current_stage = StageSeriesAngleBased(self.next_tilt_id)

        self.run_continuously = args.run_mode == "continuous"

        lmod_provider = LmodEnvProvider(args.lmod_path)

        self.motion_corr_runner = MotionCorr3(
            lmod=lmod_provider.with_modules(args.get('motioncorr_module', 'MotionCor3/1.0.1')),
            out_dir=self.run_dir,
            voltage=args.voltage,
            apix=args.apix,
            pre_dose=args.pre_dose,
            frame_dose=args.frame_dose,
            gain_file=args.get('gain_file', None),
            gpu_id=0)

        self.ctf_runner = CtfFind5(
            lmod=lmod_provider.with_modules(args.get('ctf_module', 'ctffind/5.0.2')),
            out_dir=self.run_dir,
            voltage=args.voltage,
            apix=args.apix,
            cs=args.cs,
            ac=args.ac,
            pwr_size=args.pwr_size,
            defocus_min=args.defocus_min,
            defocus_max=args.defocus_max,
            res_min=args.res_min,
            res_max=args.res_max,
            phase_plate=args.phase_plate,
            min_phase_shift=args.min_phase_shift,
            max_phase_shift=args.max_phase_shift)

        self.are_tomo_runner = AreTomo(
            lmod=lmod_provider.with_modules(
                args.get('aretomo_module', ' areTomo/1.3.4'),
                args.get('cuda_module', 'cuda/11.6.1')),
            out_dir=self.run_dir,
            apix=args.apix,
            binning=args.tomo_bin,
            tilt_axis=args.tilt_axis,
            voltage=args.voltage,
            thickness=args.vol_z
        )

        self.imod_runner = Imod(env_setup=lmod_provider.with_modules(args.get('imod_module', 'imod')))


    def _load_state(self):
        if self.processed_mics_file.exists():
            self.processed_mics = set(self.processed_mics_file.read_text().splitlines())
        if self.last_id_file.exists():
            self.next_tilt_id = int(self.last_id_file.read_text()) + 1

    def consume_next_micrograph(self, mic: Micrograph):
        """ Expect micrographs given in sorted order - as generated by the instrument """

        # Lets run motioncorr/ctf on micrograph first
        self.logger.info("TOMO: processing movie " + mic.data_file.name + "- motioncor + ctf")
        out_mrc = self.run_dir / (mic.data_file.stem + ".mrc")
        mic.corrected_data_file, dose = self.motion_corr_runner.run(in_micrograph=mic.data_file, out_micrograph=out_mrc, skip_if_results_exist=True)

        # Lets run ctf estimation
        ctf_pwr_path = self.run_dir / (mic.data_file.stem + "_pwr.mrc")
        mic.ctf_result = self.ctf_runner.run(mic.corrected_data_file, ctf_pwr_path, skip_if_results_exist=True)

        # After this is done, lets give this to group
        added = self.current_stage.try_add_micrograph(mic)
        self.logger.info("TOMO: micrograph generated, adding to tilt series")
        if not added:
            self.logger.info(f"TOMO: stage shift () completed, generating tilt series and tomograms...")
            tilt_sers = self.process_stage()
            self.current_stage = StageSeriesAngleBased(self.next_tilt_id, first_mic=mic)
            return tilt_sers

    def set_gainfile(self, path: pathlib.Path):
        self.motion_corr_runner.gain_file = path

    def mark_micrographs_as_processed(self, mics):
        with open(self.processed_mics_file, "a") as f:
            for mic in mics:
                self.processed_mics.add(mic.data_file.name)
                f.write(mic.data_file.name + "\n")

    def mark_tilt_id(self, tilt_id):
        self.last_id_file.write_text(str(tilt_id))
        self.next_tilt_id = tilt_id + 1

    def process_stage(self):
        tilt_sers = self.current_stage.find_tilt_series()
        self.logger.info(f"Stage shift, processing {len(tilt_sers)} tilt series")
        for ts in tilt_sers:
            ts.dump_tilt_angles(self.run_dir / f"tomo_{ts.series_id}.tlt")
            ts.dump_ctf_results(self.run_dir / f"defocus_file_{ts.series_id}.txt")
            ts.dump_raw_movies(self.run_dir / f"movies_{ts.series_id}.txt")

            # For each titl series - newstack
            self.logger.info(f"TOMO: stacking tilt series {ts.series_id}")
            ts.stack(
                self.run_dir / f"tomo_{ts.series_id}.mrc",
                self.run_dir / f"tomo_{ts.series_id}_pw.mrc",
                self.imod_runner)

            # Reconstruct tomogram...
            self.logger.info(f"TOMO: reconstructing tomogram {ts.series_id}")
            tomogram_file = self.run_dir / f"volume_{ts.series_id}.mrc"
            ts.are_tomo_result = self.are_tomo_runner.run(ts.stack_file, tomogram_file, ts.tilt_angle_file)

            # Tilt series done - mark id, clean, moves...
            ts.move_results(self.working_dir / ts.series_name)
            self.mark_micrographs_as_processed(ts.micrographs)
            self.mark_tilt_id(ts.series_id)
            self.logger.info(f"TOMO: tilt series {ts.series_id} done")

        return tilt_sers

    def cleanup(self):
        shutil.rmtree(self.run_dir, ignore_errors=True)

    def scan_movies(self):
        return data_tools.multiglob(self.source_dir, self.movie_patterns)

    def scan_gainfile(self):
        return next(data_tools.multiglob(self.source_dir, self.gain_patterns), None)

    def run(self):
        if self.run_continuously:
            while True:
                self.run_single()
                time.sleep(10)
        else:
            return self.run_single()

    def run_single(self, no_new_mics_expected=False):
        glb_movies = MicrographScanner(iter(m[0] for m in self.scan_movies()))

        gain_file = self.scan_gainfile()
        if gain_file:
            self.set_gainfile(self.source_dir / gain_file[0])

        try:
            while True:
                data, meta = next(glb_movies)

                # Skip already processed micrographs
                if data.name in self.processed_mics:
                    continue

                try:
                    mic = Micrograph.parse(self.source_dir / data, self.source_dir / meta)
                    # We do tilt series processing only if not done on mic...
                    tilt_sers = self.consume_next_micrograph(mic)
                    if tilt_sers:
                        self.logger.info(f"New tilt series generated: {tilt_sers}")
                        # If we generated new tilt series, move raw movies accordingly
                        pass
                except InvalidMicrographType:
                    self.logger.warning(f"Skipping {data}")
                    continue
                except Exception as e:
                    self.logger.error(f"Failed to process {data}", exc_info=e)
        except StopIteration:
            # If no new data will arrive, process last tilt series
            if no_new_mics_expected:
                self.process_stage()

